
import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.MouseListener;

public class GOLinterface extends javax.swing.JFrame implements Runnable  {

     //FIELDS 
     int width; //the width of the JPanel
     int height;
     int border = 10;
     int numCellsX; 
     int numCellsY;
     int cellSizeX;
     int cellSizeY;
    
     Color aliveColor = Color.red;
     Color deadColor = Color.white;
    
     //These arrays get initialized when the user clicks Start, which calls the startButtonActionPerformed() method below
     boolean alive[][]; 
     boolean aliveNext[][];
     
     int millisecondsBetweenFrames; //Gets reset whenever the user drags the Speed slider bar to a new position
     int milliSecMin = 20, milliSecMax = 1000; //The min and max sleep durations corresponding to the highest and lowest settings of the speed slider bar.
     double sliderSlope, sliderIntercept; //used to help calculate millisecondsBetweenFrames based on the speed slider bar's position

     boolean paused = false;
     
     Thread animator; //Needed to allow the animation to be paused and restarted when the user clicks Start, Pause or Resume.
     
     
     /* ***********************
      * CLASS METHODS
      * ************************/
     
    //THE initComponents() METHOD WAS AUTOMATICALLY GENERATED BY NETBEANS AS SOON 
    //AS I CREATED THE GUI FORM. YOU GENERALLY NEVER NEED TO LOOK AT THIS CODE.
    //IT GETS CALLED BY THE CONSTRUCTOR, WHICH IS CALLED INSIDE main().
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        GOLgrid = new javax.swing.JPanel();
        startButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        pauseAndResumeButton = new javax.swing.JButton();
        gridSize = new javax.swing.JTextField();
        speedSlider = new javax.swing.JSlider();
        jLabel2 = new javax.swing.JLabel();
        clearButton = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        GOLgrid.setBackground(new java.awt.Color(51, 51, 255));
        GOLgrid.setPreferredSize(new java.awt.Dimension(700, 700));
        GOLgrid.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                mouseDrag(evt);
            }
        });
        GOLgrid.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                GOLinterface.this.mouseReleased(evt);
            }
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                GOLinterface.this.mouseClicked(evt);
            }
        });

        javax.swing.GroupLayout GOLgridLayout = new javax.swing.GroupLayout(GOLgrid);
        GOLgrid.setLayout(GOLgridLayout);
        GOLgridLayout.setHorizontalGroup(
            GOLgridLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 700, Short.MAX_VALUE)
        );
        GOLgridLayout.setVerticalGroup(
            GOLgridLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 700, Short.MAX_VALUE)
        );

        startButton.setBackground(new java.awt.Color(102, 255, 51));
        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        jLabel1.setText("Grid size");

        pauseAndResumeButton.setText("Pause");
        pauseAndResumeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pauseAndResumeButtonActionPerformed(evt);
            }
        });

        gridSize.setText("30");
        gridSize.setMinimumSize(new java.awt.Dimension(50, 28));

        speedSlider.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                dragged(evt);
            }
        });

        jLabel2.setText("Speed");

        clearButton.setLabel("Clear");
        clearButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearButtonActionPerformed(evt);
            }
        });

        jLabel3.setText("Drag anywhere to add new cells");

        jLabel4.setText("Click anywhere to add an individual cell");

        jLabel5.setText("Then click Pause/Resume twice to continue animating");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(GOLgrid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(gridSize, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(speedSlider, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(startButton)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(71, 71, 71)
                                        .addComponent(pauseAndResumeButton)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(clearButton))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(16, 16, 16)
                        .addComponent(jLabel2))
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel4)
                            .addComponent(jLabel3)
                            .addComponent(jLabel5))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(22, 22, 22)
                        .addComponent(GOLgrid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(51, 51, 51)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(gridSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(startButton)
                            .addComponent(pauseAndResumeButton)
                            .addComponent(clearButton))
                        .addGap(18, 18, 18)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(speedSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel3)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel5)))
                .addContainerGap(78, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    //THE USUAL COLLECTION OF METHODS USED BY ANY GAME OF LIFE PROGRAM
    
    public void plantFirstGeneration()  {
        makeEveryoneDead();

        plantGlider(1, 2, 4);
        plantGlider(numCellsX-4, 2, 1);
        plantGlider(numCellsX-4, numCellsX-4, 2);
        plantGlider(1, numCellsX-4, 3);
    }
    
    
    public void makeEveryoneDead() {
        for (int i = 0; i < numCellsX; i++) {
            for (int j = 0; j < numCellsY; j++) {
                alive[i][j] = false;
            }
        }
    }
    
    
    public void plantGlider(int startX, int startY, int direction) {

        alive[startX][startY] = true;
        alive[startX + 1][startY] = true;
        alive[startX + 2][startY] = true;

        switch (direction) {
            case 1: //SOUTHWEST
            {
                alive[startX][startY - 1] = true;
                alive[startX + 1][startY - 2] = true;
                break;
            }
            case 2: //NORTHWEST
            {
                alive[startX][startY + 1] = true;
                alive[startX + 1][startY + 2] = true;
                break;
            }
            case 3: //NORTHEAST
            {
                alive[startX + 2][startY + 1] = true;
                alive[startX + 1][startY + 2] = true;
                break;
            }
            case 4: //SOUTHEAST
            {
                alive[startX + 2][startY - 1] = true;
                alive[startX + 1][startY - 2] = true;
                break;
            }
        }
    }
    
    
    public void computeNextGeneration() {
        int numNeighbors = 0;

        for (int i = 0; i < numCellsX; i++) {
            for (int j = 0; j < numCellsY; j++) {
                
                numNeighbors = countNeighbors(i, j);

                if (alive[i][j]) { 
                    
                    if (numNeighbors <= 1 || numNeighbors >= 4) 
                        aliveNext[i][j] = false;
                    else 
                        aliveNext[i][j] = true;                   
                }
                
                else if (numNeighbors == 3) 
                    aliveNext[i][j] = true;
                
                else 
                    aliveNext[i][j] = false;
                
            }
        }
    }
    
    
    public void plantNextGeneration() {
        for (int i = 0; i < numCellsX; i++) {
            for (int j = 0; j < numCellsY; j++) {
                alive[i][j] = aliveNext[i][j];
            }
        }
    }
    
    
    public int countNeighbors(int i, int j) {
        int count = 0;
        int startRow;
        int startCol;
        int endRow;
        int endCol;

        if (i == 0)
            startCol = i;
        else 
            startCol = i - 1;
        
        if (i == numCellsX - 1) 
            endCol = i;
        else 
            endCol = i + 1;       

        if (j == 0) 
            startRow = j;
        else 
            startRow = j - 1;
        
        if (j == numCellsY - 1) 
            endRow = j;
        else 
            endRow = j + 1;
        
        for (int m = startCol; m <= endCol; m++) {
            for (int n = startRow; n <= endRow; n++) {
                
                if (m != i || n != j) {
                    if (alive[m][n]) 
                        count++;                   
                }
            }
        }
        return count;
    }
    
    
    //THIS METHOD TAKES THE PLACE OF paint() AND repaint().
    //IT GETS CALLED REPEATEDLY INSIDE THE WHILE-LOOP IN THE run() METHOD BELOW
    public void drawGrid() {
        
        //For drawing on a JPanel (as opposed to a JFrame), we "make" the Graphics object g by
        //extracting it from the JPanel object, which we named GOLgrid
        Graphics g = GOLgrid.getGraphics();
        
        //Now that we have g, the rest of the method is exactly the same as the paint() method
        //in the Game of Life programs you wrote
        int x, y, i, j;
        x = border;

        for (i = 0; i < numCellsX; i++) {
            y = border;
            
            for (j = 0; j < numCellsY; j++) {
                
                if (alive[i][j]) 
                    g.setColor(aliveColor);
                
                else 
                    g.setColor(deadColor);
                

                g.fillRect(x, y, cellSizeX, cellSizeY); //paint the current box red or white
                
                
                if( numCellsX < 70 ) { //saves considerable CPU time (and thus speeds things up) when the grid size is large
                   
                    //draws a grey outline around the box
                    g.setColor( new Color(150,150,150));
                    g.drawRect(x, y, cellSizeX, cellSizeY);
                }
                
                y += cellSizeY;
            }
            x += cellSizeX;
        }
    }
    
    
    //GETS CALLED WHENEVER THE USER CLICKS THE Start BUTTON
    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        clearScreen();
        initializeGrid();
        plantFirstGeneration();
        animator = new Thread( this );  //Allows the animation while-loop in the run() method to continue.  Setting animator to null makes the animation loop stop.
        animator.start();
    }//GEN-LAST:event_startButtonActionPerformed

    
    //CLEARS THE SCREEN. IT'S CALLED BY THE METHOD ABOVE, WHICH GETS CALLED WHEN THE Start BUTTON IS CLICKED
    public void clearScreen() {
        Graphics g = GOLgrid.getGraphics();
        
        g.setColor(Color.blue); 
        g.fillRect(0, 0, width, height); //clears the screen by drawing a blank blue rectangle over the whole JPanel
    }


    //GETS CALLED WHENEVER THE USER CLICKS THE Pause/Resume BUTTON
    private void pauseAndResumeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pauseAndResumeButtonActionPerformed
        
        if ( animator == null ) { //if the animation is currently paused...
            
            //...then restart the animation (because the button's label was "Resume" when the user clicked it just now)
            animator = new Thread( this ); //restarts the Thread object that keeps the animation loop going in the run() method below
            animator.start();
            pauseAndResumeButton.setText( "Pause" );
            paused = false;
        }
        
        else {  //if the animation is currently running...
            
            //...then stop the animation (because the button's label was "Pause" when the user clicked it just now)
            animator = null; //kills the Thread object, which interrupts the animation loop in the run() method below
            pauseAndResumeButton.setText( "Resume" );
            paused = true;
        }        
    }//GEN-LAST:event_pauseAndResumeButtonActionPerformed

    
    //GETS CALLED WHENEVER THE USER DRAGS THE SPEED SLIDER BAR TO A NEW POSITION
    private void dragged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_dragged
        setSleepDuration();
    }//GEN-LAST:event_dragged

    
    //GETS CALLED WHENEVER THE USER DRAGS THE MOUSE.
    //IT SETS THE CELL THAT THE MOUSE IS CURRENTLY ON TO true.
    private void mouseDrag(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mouseDrag
        paused = true; //pauses recalculation of the next generation so that the grid is not updating while the user is adding new living cells 
        int x = evt.getX(), y = evt.getY(); //the (x,y) coordinates of the mouse at this instant
        int i = getXcell( x ); 
        int j = getYcell( y );
        alive[i][j] = true; //makes cell (i,j) alive
    }//GEN-LAST:event_mouseDrag

    
    //GETS CALLED WHENEVER THE USER CLICKS THE MOUSE.
    //IT CHANGES THE CELL THAT THE MOUSE IS ON TO THE OPPOSITE OF ITS CURRENT VALUE.
    private void mouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mouseClicked
        paused = true;
        int x = evt.getX(), y = evt.getY();
        int i = getXcell(x);
        int j = getYcell(y);
        alive[i][j] = !alive[i][j]; //sets alive[i][j] to the opposite of its current value      
    }//GEN-LAST:event_mouseClicked

    
    //GETS CALLED WHENEVER THE USER RELEASES THE MOUSE AFTER DRAGGING OR CLICKING.
    //IT SETS paused TO false SO THAT RECALCULATION OF THE NEXT GENERATION RESUMES
    //AS SOON AS THE USER IS DONE ADDING NEW CELLS
    private void mouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mouseReleased
        paused = false;
    }//GEN-LAST:event_mouseReleased

    
    //GETS CALLED WHENEVER THE USER PRESSES THE Clear BUTTON
    private void clearButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearButtonActionPerformed
        makeEveryoneDead(); //sets all cells to dead
    }//GEN-LAST:event_clearButtonActionPerformed

    
    //RETURNS THE INDEX OF THE CELL COLUMN THAT CORRESPONDS TO SCREEN COORDINATE x.
    //THE METHOD GETS CALLED WHENEVER THE USER DRAGS WITH THE MOUSE OVER THE GRID IN ORDER TO PLANT CELLS
    public int getXcell(int x) {
        return (x-border)/cellSizeX;
    }
    
    
    //RETURNS THE INDEX OF THE CELL ROW THAT CORRESPONDS TO SCREEN COORDINATE y.
    //THE METHOD GETS CALLED WHENEVER THE USER DRAGS WITH THE MOUSE OVER THE GRID IN ORDER TO PLANT CELLS
   public int getYcell(int y) {
        return (y-border)/cellSizeY;
    }
    
   
    //SETS THE THE NUMBER OF MILLISECONDS BETWEEN FRAMES USING THE CURRENT POSITION OF THE SPEED SLIDER BAR
    public void setSleepDuration() {
        int x = speedSlider.getValue();
        millisecondsBetweenFrames = (int)(sliderSlope*x + sliderIntercept);
    }
    
    
    //GETS THE GRID SIZE FROM THE TEXT BOX AND INITIALIZES THE ARRAYS alive[][] 
    //AND aliveNext[][] USING THAT SIZE.  IT ALSO DETERMINES THE CELL SIZE IN PIXELS.
    //IT GETS CALLED ONCE IN main() WHEN THE PROGRAM FIRST LOADS, AND ALSO GETS CALLED WHENEVER THE Start BUTTON IS CLICKED.
    public void initializeGrid() {
        
        numCellsX = Integer.parseInt( gridSize.getText() ); //Gets the grid size from the text box.
                                                            //getText() returns a String, so we have to
                                                            //apply Integer.parseInt() to it to turn it into an int.
        numCellsY = numCellsX;
        
        alive = new boolean[numCellsX][numCellsY];
        aliveNext = new boolean[numCellsX][numCellsY];
        
        width = GOLgrid.getWidth(); //the width of the JPanel
        height = GOLgrid.getHeight();
        
        cellSizeX = (width-2*border) / numCellsX;
        cellSizeY = (width-2*border) / numCellsY; 
        
        sliderSlope = -(milliSecMax-milliSecMin)/100;
        sliderIntercept = milliSecMin - sliderSlope*100;
        setSleepDuration(); 
    }
    
    
    //run() IS A SPECIAL METHOD THAT IS INCLUDED IN ANY JAVA CLASS THAT HAS "implements Runnable" IN ITS CLASS DECLARATION.
    //YOU PROVIDE THE CODE INSIDE IT, AND JAVA AUTOMATICALLY CALLS THE METHOD CONTINUOUSLY, AGAIN AND AGAIN, FOR AS
    //LONG AS THE PROGRAM IS RUNNING.  IN THIS CASE, I'VE CODED run() SO THAT THE ANIMATION GETS INTERRUPTED 
    //OR RESTARTED WHENEVER THE USER CLICKS Start, Pause OR Resume.
    public void run() {
        
        //this while-loop runs the Game of Life animation
        while( Thread.currentThread() == animator ) {  //This while-condition becomes false when the user clicks the Pause
                                                       //button, and becomes true again when the user clicks the Resume button.
            sleep( millisecondsBetweenFrames ); 
            
            if ( !paused ) { //'paused' becomes true when the user is dragging the mouse to plant new living cells.
                             //Thus, this if-statement prevents the program from trying to compute or draw the next generation 
                             //while the user is still busy adding new cells                
                computeNextGeneration();   
                plantNextGeneration();                  
            }  
            
            drawGrid(); //Re-draws the grid using the current values in the alive[][] array. 
                        //The drawGrid() method takes the place of paint() or repaint(), which would be used if we
                        //were drawing on a JFrame instead of a JPanel.
        }
    }
    
    
    public static void sleep(int duration) {
        try {
            Thread.sleep( duration );
        } 
        catch (Exception e) {}
    }

    
    //THE CONSTRUCTOR.  THE CODE IN THE METHOD initComponents() IS 
    //AUTOMATICALLY GENERATED BY NETBEANS WHEN YOU CREATE THE GUI FORM
    public GOLinterface() {
        initComponents();
    }

    
    //GETS CALLED AS SOON AS YOU RUN THE PROGRAM
    public static void main(String args[]) {
        
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GOLinterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GOLinterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GOLinterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GOLinterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //NetBeans automatically generated the next 3 lines of code...
        java.awt.EventQueue.invokeLater(new Runnable() { 
            public void run() { 
                
                GOLinterface gi = new GOLinterface(); //calls the constructor
                
                //...Then I added these 4 lines myself
                gi.setDefaultCloseOperation(EXIT_ON_CLOSE); //allows the GUI window to be closed when the user clicks the window's X button
                gi.setVisible(true); //opens the GUI window
                gi.initializeGrid(); //gets the grid size from the text box and initializes the alive[][] and aliveNext[][] arrays
                gi.drawGrid(); //draws the empty grid for the first time
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel GOLgrid;
    private javax.swing.JButton clearButton;
    private javax.swing.JTextField gridSize;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton pauseAndResumeButton;
    private javax.swing.JSlider speedSlider;
    private javax.swing.JButton startButton;
    // End of variables declaration//GEN-END:variables
}
